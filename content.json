[{"title":"请求数据最佳时机","date":"2018-09-03T16:00:00.000Z","path":"React_请求数据最佳时机/","text":"React生命周期初始化constructor: 在构造函数中可以初始化state 渲染render：渲染组件 挂载前后componentWillMount：在渲染前调用componentDidMount：第一次渲染后调用 更新componentWillReceiveProps：在接收到新的props时调用，render阶段不会被调用shouldComponentUpdate：接受到新的props、state时调用，返回布尔值确定是否更新组件componentWillUpdate：在接收到新的props或state但未render时被调用componentDidUpdate：组件更新完成后调用 移除componentWillUnmount：组件被移除时调用 生命周期执行顺序生命周期执行顺序如下图所示： 请求数据最佳时机componentWillMount和componentDidMount在实习过程中我刚开始写组件时，把请求数据放在了componentWillMount中，在观察了前辈们写的组件时，发现他们请求数据的代码没有放在componentWillMount中，而是写在componentDidMount中，下来查了资料后，发现在下个版本中： React将移除componentWillMount这个生命周期 componentWillMount在16.3版本前是同步的，在这里执行请求可能不会触发UI渲染，16.3版本后，这个生命周期是异步的，在这里请求可能会导致多次调用这个生命周期并且造成内存泄漏 componentDidMount不论异步还是同步都只会调用一次 所以综合考虑后，请求数据的最佳时机在componentDidMount","tags":[{"name":"React","slug":"React","permalink":"https://github.com/jacklincao/tags/React/"}]},{"title":"列表需要加上的属性——key","date":"2018-09-02T16:00:00.000Z","path":"React_列表渲染key/","text":"警告?在React中使用map等方法产生一堆组件时，如果忘记加上一个属性：key，React会提示如下图所示的警告只是一个警告而已，没提示报错，我不加可以吧？可以，当然可以，只是你的应用性能也会因此降低，所以React只是警告 影响性能？diff算法为什么不加一个key就会影响性能，这是因为React的diff算法，在每次组件更新后，有key的话可以快速帮助React定位被修改的组件，如果不加key，React会默认使用数组的下标作为key，而React不提倡使用数组的下标作为key 不能用数组下标作为key？我在实习中，刚开始接触React，自己大意了，在code review，我的mentor给我指出了这个问题，下来专门查了资料，能使用数组下标，但会产生一些奇怪的bug，如果数组顺序发生变化，触发diff后将引起浏览器重绘，如果你的组件不会变，那么你可以使用数组的下标作为key，如果会变，那就使用数据的唯一id作为标识，举个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Hello extends React.Component &#123; constructor() &#123; super() this.state = &#123; data: [ &#123; name: &apos;a&apos;, id: 1 &#125;, &#123; name: &apos;b&apos;, id:2 &#125;, &#123; name: &apos;c&apos; &#125; ] &#125; &#125; revertData = () =&gt; &#123; let data = this.state.data let newData = [].concat(data) newData.push(newData.shift()) this.setState(&#123;data: newData&#125;) &#125; render() &#123; let state = this.state // 不加key和使用index作为key的效果一样，都会给出警告，如果使用id作为key就不会出现问题 return( &lt;ul&gt; &#123; state.data.map((item, index) =&gt; &#123; return &lt;li key=&#123; index &#125;&gt;&#123; item.name &#125;&lt;input type=&apos;input&apos; /&gt;&lt;/li&gt; &#125;) &#125; &lt;button onClick=&#123;this.revertData&#125;&gt;revert&lt;/button&gt; &lt;/ul&gt; ) &#125;&#125;ReactDOM.render( &lt;Hello/&gt;, document.getElementById(&apos;container&apos;));","tags":[{"name":"React","slug":"React","permalink":"https://github.com/jacklincao/tags/React/"}]},{"title":"函数重载","date":"2018-08-09T12:00:35.000Z","path":"JavaScript_重写和重载/","text":"重写和重载重载就是函数名一致，但是参数个数不同或类型不同重写就是子类覆盖父类中的同一个方法，将其覆盖已达到重写的目的载JavaScript中实现重写的几个思路：1.重写原型对象2.在实例中添加和原型中一样的函数，根据调用函数的规则:实例优先与原型调用 在JavaScript中实现重载的几个思路：1.根据参数个数进行判断，然后调用不同的处理逻辑2.使用闭包 实现重载思路1：通过参数个数判断应该进行什么样的处理，优点：代码清晰明了缺点：可扩展性差12345678910function add() &#123; let argLength = arguments.length; if(argLength === 0) &#123; // 进行相应处理 &#125; else if(argLength === 1) &#123; // 进行相应处理 &#125; ... // 可以接着进行判断、处理&#125; 思路2：通过闭包保存旧方法实现重写优点：可扩展性好，可以动态的添加缺点：仅实现参数个数不同的重写，未进行参数类型不同时的重写1234567891011121314151617181920212223242526272829303132333435function overloading(obj, methodName, fn) &#123; let oldMethod = obj[methodName] obj[methodName] = function() &#123; if(fn.length === arguments.length) &#123; return fn.apply(this, arguments) &#125; else if(typeof oldMethod === &apos;function&apos;) &#123; return oldMethod.apply(this, arguments) &#125; &#125;&#125;var calculate = &#123; a: 1, b: 2, c: 3&#125;overloading(calculate, &apos;add&apos;, function() &#123; // 无参数的add方法 return 0&#125;)overloading(calculate, &apos;add&apos;, function(a) &#123; // 有一个参数的add方法 return this[a]&#125;)overloading(calculate, &apos;add&apos;, function(a, b) &#123; // 有两个参数的add方法 return this[a] + this[b]&#125;)overloading(calculate, &apos;add&apos;, function(a, b, c) &#123; // 有三个参数的add方法 return this[a] + this[b] + this[c]&#125;)calculate.add() // 0calculate.add(&apos;a&apos;) // 1calculate.add(&apos;a&apos;, &apos;b&apos;) // 3calculate.add(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // 6","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"图片懒加载技术","date":"2018-05-04T10:51:25.000Z","path":"前端性能优化_ 图片懒加载技术/","text":"浏览器相关高度、宽度网页可视区高/宽：1.clientHeight/clientWidth:height+padding-滚动轴高度2.offsetHeight/offsetWidth:height+padding+border+滚动轴高度 网页全文高/宽1.scrollHeight/scrollWidth:1)有滚动条时:包含所有的高度(隐藏的部分也算入)2)无滚动条时:值=clientHeight/clientWidth 网页滚动距离scrollTop/scrollLeft:1)无滚动条时:值=02)有滚动条时:值=滚动的距离 相对于父容器的 左方/上方 距离offsetLeft/offsetTop=marginLeft+offsetParent的(paddingLeft+borderLeft+marginLeft) 左/上 边框宽度clientLeft/clientTop=边框的宽度 判断元素位于页面底部判断元素到底部:clientHeight===scrollHeight-scrollTop 图片懒加载懒加载机制网页需要展示很多图片，而用户可能没有接着浏览余下图片的意图，这样就浪费了很大的资源，一次请求了那么多图片，而且一张图片还有几兆，结果实际上没用到，所以为了减少服务器的压力，使用懒加载技术，不直接给图片标签加上src，给图片加上新的属性，其中保存真正的src，例如data-src，当用户浏览到图片时才进行加载。 判断用户当前浏览的位置如图所示，当图片：滚动高度+可视区高度&gt;图片距离顶部的距离时就将data-src替换到src即可 注意：不要在img标签上加src属性，如果设置src=””，大多数浏览器仍会请求，而且请求的是当前页面数据。 原生js实现的demo123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片&lt;/title&gt; &lt;style&gt; img &#123; display: block; width: 500px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt; &lt;img alt=&quot;&quot; data-scr=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497274158197&amp;di=8845befd9fbda1e99e565b9c2298be50&amp;imgtype=0&amp;src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1503%2F626-15031G42255b3.jpg&quot;&gt;&lt;script&gt; var imgs = document.querySelectorAll(&apos;img&apos;);//获取所有图片 var length = imgs.length; var n = 0;//保存已经加载了的图片数量 // window.onload = lazyLoadImg; window.onscroll = lazyLoadImg; function lazyLoadImg() &#123; var userHeight = document.documentElement.clientHeight; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; for(var i =n; i &lt; length; i++) &#123; if(imgs[i].offsetTop &lt; userHeight + scrollTop) &#123; if(imgs[i].getAttribute(&apos;src&apos;) === &apos;&apos; || imgs[i].getAttribute(&apos;src&apos;) === null) &#123; imgs[i].src = imgs[i].getAttribute(&apos;data-scr&apos;); &#125; n = i + 1; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://github.com/jacklincao/tags/前端性能优化/"}]},{"title":"单行、多行文本显示省略号","date":"2018-04-13T08:51:25.000Z","path":"CSS_单行多行文本显示省略号/","text":"实现单行文本溢出省略号展示123456p &#123; text-overflow:ellipsis;//text-overflow属性规定文本溢出时的操作 white-space: nowrap;//源文档中的空白符,如空格、换行；pre保持原格式,nowrap不换行,normal将空格合并为一个并忽略换行 overflow: hidden;// /*width: 3em;*/&#125; 实现多行文本溢出省略号展示只在webkit内核浏览器和移动端有用:123456p &#123; display: -webkit-box;//设置展示为弹性伸缩盒子 -webkit-line-clamp: 2;//显示的文本行数 -webkit-box-orient: vertical;//子元素排列方式 overflow: hidden;&#125; 解决跨浏览器兼容性:任何时候都会带有省略号，需要配合js使用123456789101112131415161718p &#123; position: relative; line-height: 1.4em; height: 4.2em;//需为line-height的整数倍 overflow: hidden;&#125;p::after &#123; content: &apos;...&apos;; position: absolut; bottom: 0; right: 0; padding-left: 40px; background:-webkit-linear-gradient(left,transparent,#fff 55%); background:-o-linear-gradient(right,transparent,#fff 55%); background:-moz-linear-gradient(right,transparent,#fff 55%); background:linear-gradient(to right,transparent,#fff 55%);&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/jacklincao/tags/CSS/"}]},{"title":"阿里云Ubuntu16.04下MySQL配置","date":"2018-03-26T09:00:46.615Z","path":"MySQL_阿里云配置/","text":"连接出错:Can’t connect to mysql server on xxx.xxx.xxx.xxx(10038)解决方法：1.修改/etc/mysql/mysql.conf.d 文件，将bind-address从127.0.0.1修改为0.0.0.02.授权12mysql&gt;grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by 密码 with grant option;mysql&gt;flush privileges; 3.进入阿里云控制台设置安全组，添加公网入方向配置：允许 自定义 TCP 3306/3306 地址段访问 0.0.0.0/0","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/jacklincao/tags/MySQL/"}]},{"title":"Windows下MySQL数据备份与还原","date":"2018-01-21T13:03:13.000Z","path":"MySQL_备份还原/","text":"MySQL备份在MySQL中，如果视图比较多，同时视图之间存在嵌套、调用关系，为了在还原时不会报错，最好使用cmd命令备份，我使用Navicat备份过，但是由于视图太多还原失败了，运行下面的MySQL备份命令： cd C:\\Program Files\\MySQL\\MySQL x.x\\bin //进入mysql的bin目录 mysqldump -u 用户名 -p 数据库名 &gt;导出的文件名 //会要求输入密码，而产生的文件将在bin目录下 MySQL还原将刚才备份得到的文件放到另一台机器的MySQL的bin目录下，运行下面的MySQL还原命令： mysql -u 用户名 -p //之后将输入密码 mysql&gt;use 目标数据库 //选择需要还原的数据库 mysql&gt;source 导入的文件名 //bin目录下的文件名 在还原过程中遇到Unknown command的错误时，多半是遇上乱码了，所以此时需要加上编码设置，即 mysql -u 用户名 -p --default-character-set=utf8","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/jacklincao/tags/MySQL/"}]},{"title":"git使用日记","date":"2018-01-19T13:03:25.000Z","path":"Git_速查命令/","text":"git常用命令为了方便自己以后使用git命令，避免网上查阅，所以用这个记录了一些常用的命令： git status 查看仓库当前状态 git add xx 提交文件xx到暂存区 git diff xx 查看xx文件做了什么修改 git commit -m “描述” 提交修改时带上描述，将暂存区提交到当前分支 git log 查看commit（提交）历史记录 可加上 –pretty=oneline 过滤其它信息，加上--graph git reset --hard HEAD^ 回退到上一版本，如果有多个版本，可以使用HEAD^^（回退上上个版本），HEAD~100（回退到100个版本） git reset --hard xxxxxxx 指定回到某个版本号 git fetch --all, git reset --hard origin/master 第一条fetch下载远程的内容,第二条将当前指针指向刚刚下载的 git reflog 记录每一次命令操作 git checkout -- xx 撤销对xx文件的全部修改操作；一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git rm xx 从版本库删除xx文件 git clone git@www.xx.com:/home/xx.git 克隆到本地 git branch zz 创建zz分支 git checkout zz 切换到zz分支 git checkout -b zz 创建并切换到zz分支，是上面两条的简写，如果要将远程的zz分支同步下来,则需要:git checkout -b zz origin/zz git branch 列出所有分支，当前分支前会有* git push origin zz 将本地的zz分支推送到远程仓库 git merge zz 将zz分支合并到当前分支 git branch -d zz 删除zz分支 git merge --no-ff -m “信息” zz 将zz分支合并到当前分支，并保留zz分支信息 git stash 将工作现场存储起来，以后可以恢复 git stash list 列举保存的工作现场 git stash apply stash@{0} -&gt; git stash drop stash@{0} 先将工作现场0恢复，然后删除工作现场0 git stash pop 恢复的同时删除现场 git remote 查看远程仓库信息，加上-v显示更详细信息 git push origin zz 向远程分支推送zz分支 git pull 将最新的提交从远程抓下来，在本地进行合并后再提交 git branch –-set-upstream zz origin/zz 设置zz分支对应远程仓库的zz分支 git tag v1.0 在当前分支上创建v1.0标签，加上 5134234参数代表在这个commit上打标签 git tag 查看所有标签 git show v1.0 查看v1.0标签信息 git tag -a v1.0 -m “这是v1.0版本” 21312在当前分支的21312commit上添加标签名为v1.0，内容为”这是v1.0版本”的标签，-a指定标签明，-m指定说明文字 图1 关于分支管理的策略:图片来自廖雪峰博客 图2 关于多人协作时的工作模式：图片来自廖雪峰博客","tags":[{"name":"git使用","slug":"git使用","permalink":"https://github.com/jacklincao/tags/git使用/"}]},{"title":"Angular子路由跳转","date":"2017-10-12T11:43:02.000Z","path":"Angular_子路由跳转/","text":"配置了路由表，并定义了子路由，但是每次跳转到子路由总是跳到404路由在Angular的官方文档找到了原因：导入模块的时候需要注意顺序，我在根模块导入模块时先把主路由模块导入了，导致路由会率先匹配到通配符路由，所以跳转到404，在定义子路由时，要将子路由所在模块提前于通配符路由所在的模块！1234567891011121314151617181920212223242526272829303132//根模块路由定义在AppRoutingModule，子路由定义在FrontModule中imports: [ BrowserModule, FormsModule, HttpModule, JsonpModule, FrontModule， AppRoutingModule/*导入路由模块,顺序很重要*/ ], ......//AppRoutingModule中的路由表如下appRoutes: Routes = [ &#123;path: &apos;&apos;, redirectTo: &apos;/login&apos;, pathMatch: &apos;full&apos;&#125;, &#123;path: &apos;login&apos;, component: LoginComponent&#125;, &#123;path: &apos;**&apos;, component: PageNotFoundComponent&#125;];//FrontModule中定义的路由表如下frontRoutes: Routes = [ &#123; path: &apos;begin&apos;, component: FrontComponent, children: [ /*子路由*/ &#123;path: &apos;&apos;, component: DebateInfoComponent&#125;, &#123;path: &apos;end&apos;, component: EndComponent&#125;, ] &#125; ]; //如果AppRoutingModule先于FrontModule导入就会导致所有子路由匹配到&apos;**&apos;","tags":[{"name":"Angular常见bug","slug":"Angular常见bug","permalink":"https://github.com/jacklincao/tags/Angular常见bug/"}]},{"title":"Angular生成组件出错","date":"2017-10-08T12:02:20.000Z","path":"Angular_生成组件出错/","text":"使用Angular CLI工具生成组件出错12Error:More than one module matches. Use skip-important option to skip importing the component into the closest module.More than one module matches. Use skip-important option to skip importing the component into the closest module. 查看了Angluar CLI的官方文档，没找到原因，在stackouverflow上找到了，原因是在我的应用中有多个模块，不指明是哪一个模块的组件的话，它不知道这个组件属于谁，所以解决方法就是1ng g c \\shared\\test --module app //shared指在shared文件夹下生成test组件，它是app模块的组件 亲测成功。","tags":[{"name":"Angular常见bug","slug":"Angular常见bug","permalink":"https://github.com/jacklincao/tags/Angular常见bug/"}]},{"title":"对象拷贝(深、浅)","date":"2017-06-09T12:00:35.000Z","path":"JavaScript_对象拷贝/","text":"对象拷贝在JavaScript中，对象拷贝分为两种：浅拷贝、深拷贝 浅拷贝将一个对象中的值复制到另一个对象中（不考虑属性中是否有引用类型）,example:123456789101112131415161718192021222324252627282930var a = &#123; name: &apos;jack&apos;, age: 20 &#125; function copy(obj) &#123; var newObj = new Object(); for(let attr in obj) &#123; newObj[attr] = obj[attr]; &#125; return newObj;&#125;var newObj = copy(a);console.log(newObj.name);var b = &#123; name: &apos;lin&apos;, age: 21, bestfriends: &#123; name: &apos;l&apos;, age: 21 &#125; &#125;var c = copy(b);console.log(&apos;before update b:&apos; + b.name + &apos; &apos; + b.age + &apos; &apos; + b.bestfriends.name);console.log(&apos;before update c:&apos; + c.name + &apos; &apos; + c.age + &apos; &apos; + c.bestfriends.name);c.bestfriends.name=&apos;ll&apos;; //修改c中的bestfriends属性console.log(&apos;after update b:&apos; + b.name + &apos; &apos; + b.age + &apos; &apos; + b.bestfriends.name); //结果b中的也会随之更新console.log(&apos;after update c:&apos; + c.name + &apos; &apos; + c.age + &apos; &apos; + c.bestfriends.name); 为了解决在对象拷贝过程中将对象中的对象属性独立拷贝出来，所以有了深拷贝 深拷贝1.使用递归实现拷贝1234567891011121314151617181920212223242526function depthCopy(obj) &#123; if(typeof obj !== &apos;object&apos;) &#123; return obj; &#125; var newObj = &#123;&#125;; for(let attr in obj) &#123; newObj[attr] = depthCopy(obj[attr]); &#125; return newObj;&#125;var b = &#123; name: &apos;lin&apos;, age: 21, bestfriends: &#123; name: &apos;l&apos;, age: 21 &#125; &#125; var c = depthCopy(b);console.log(&apos;before update b.bestfriends.name: &apos; + b.bestfriends.name)console.log(&apos;before update c.bestfriends.name: &apos; + c.bestfriends.name)c.bestfriends.name = &apos;jacklincao&apos; //修改c.bestfrinds对象console.log(&apos;after update b.bestfriends.name: &apos; + b.bestfriends.name) //b中的不变console.log(&apos;after update c.bestfriends.name: &apos; + c.bestfriends.name) //c中的变了，说明b和c现在没有指向同一个对象，实现了深复制 2.使用JSON序列化123456789101112131415var b = &#123; name: &apos;lin&apos;, age: 21, bestfriends: &#123; name: &apos;l&apos;, age: 21 &#125; &#125; var c = JSON.parse(JSON.stringify(b)); console.log(&apos;before update b.bestfriends.name: &apos; + b.bestfriends.name)console.log(&apos;before update c.bestfriends.name: &apos; + c.bestfriends.name)c.bestfriends.name = &apos;jacklincao&apos; //修改c.bestfrinds对象console.log(&apos;after update b.bestfriends.name: &apos; + b.bestfriends.name) //b中的不变console.log(&apos;after update c.bestfriends.name: &apos; + c.bestfriends.name) //c中的变了，说明b和c现在没有指向同一个对象，实现了深复制","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"URI、URL、URN区别","date":"2017-05-10T11:20:12.000Z","path":"URI、URL、URN/","text":"什么是URI、URL、URN?URI：Uniform Resource Identifier 即“统一资源标识符”URL：Uniform Resource Locator 即“统一资源定位符”URN：Uniform Resource Name 即“统一资源名称”三者的关系如图： 用途URI用来标识资源，而URL用来指定资源所在的位置，所以URI是URL的父类，每个URL都是URI，但每个URI不一定是URL，URN未流行开下面列举了“RFC3986:Uniform Resource Identifier (URI): Generic Syntax”中举的URI例子： ftp://ftp.is.co.za/rfc/rfc1808.txt http://www.ietf.org/rfc/rfc2396.txt ldap://[2001:db8::7]/c=GB?objectClass?one mailto:John.Doe@example.com news:comp.infosystems.www.servers.unix tel:+1-816-555-1212 telnet://192.0.2.16:80/ urn:oasis:names:specification:docbook:dtd:xml:4.1.2","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://github.com/jacklincao/tags/HTTP/"}]},{"title":"http协议","date":"2017-05-03T04:02:23.000Z","path":"HTTP_协议/","text":"HTTP简介HTTP：HyperText Transfer Protocol 即“超文本传输协议”，现版本为HTTP 1.1HTTP是由客户端发起请求，服务端响应，若是没有客户端的请求，服务端也不会自动响应HTTP通信实际上是由TCP/IP负责，所以每次通信都需经过“三次握手、四次分手”，如果多次进行通信，将会耗费大量的资源，所以在HTTP 1.1版本中实现了持久连接，只要一建立连接就会一次性将所有资源下载，避免将时间浪费在连接上HTTP是无状态的协议，不会记录用户曾经的记录，所以为了实现有状态而又不破坏HTTP本身的快捷，所以有了一个叫做Cookie的东西来帮助实现，客户端第一次请求服务器时不会带有Cookie，服务器响应时在响应头中加上set-cookie，客户端将保存这个cookie，客户端第二次请求时就会带上这个cookie，服务器就知道是谁在请求了 HTTP常用方法GET：获取资源POST：传输实体主体，与GET很像，但其主要目的不是获取资源PUT：传输文件，自身不带验证机制HEAD：获取报文首部，和GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的时间等DELETE：删除文件，与PUT方法相反，用于删除指定的资源文件OPTIONS：询问支持的方法，用来查询针对请求URI指定的资源支持的方法TRACE：追踪路径，可查询发送出去的请求是怎样被加工修改/篡改的CONNECT：要求用隧道协议连接代理，在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要用SSL和TLS协议LINK和UNLINK：在1.0版本中存在，1.1版本取消*：PUT和DELETE本身不带验证机制，所以一般网站不用","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://github.com/jacklincao/tags/HTTP/"}]},{"title":"HTTP状态码","date":"2017-04-28T11:12:11.000Z","path":"HTTP_状态码/","text":"1.五类状态码 1XX 信息性状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需进行附加操作已完成请求 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器错误状态码 服务器处理请求出错 2.各类状态码详细信息2.1 2XX200 OK 请求正常204 No Content 请求处理成功，但无资源可返回：客户端向服务器发送信息，而服务器对客户端无需发送新信息206 Partial Content 返回指定范围的实体内容：客户端进行范围请求，服务器成功执行该请求，响应报文中包含Content-Range 2.2 3XX301 Moved Permanently 永久性重定向：表示请求的资源已被分配新URI，以后应使用资源现在所指定的URI302 Found 临时性重定向：表示请求的资源已被分配新的URI，希望用户（本次）使用新的URI访问303 See Other 表示请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源，与302有相同功能，但303明确要求客户端使用GET方法304 Not Modified 表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况，附带条件的请求是指采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任意首部 2.3 4XX400 Bad Request 表示请求报文中存在语法错误401 Unauthorized 表示请求需有通过HTTP认证的证书信息403 Forbidden 表明服务器拒绝了对请求资源的访问404 Not Found 表明服务器无法找到请求的资源 2.4 5XX500 Internal Server Error 表明服务器在执行请求时发生错误503 Service Unavailable 表明服务器暂处于超负载或正进行停机维护，现在无法处理请求","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://github.com/jacklincao/tags/HTTP/"}]},{"title":"encodeURI()、encodeURIComponent(）","date":"2017-02-04T06:16:35.000Z","path":"JavaScript_encodeURI/","text":"URI编码方法在JavaScript中有两个为URI进行编码的方法，一个是encodeURI()，另一个是encodeURIComponent()，两者用于不同的地方 encodeURI()用途：对整个URI进行编码，多用于整个URI编码结果：将URI中的空格替换成%20 encodeURI(&quot;http://www.baidu.com&quot;);//&quot;http://www.baidu.com&quot; encodeURI(&quot;http://www.baidu.com?hello world!&quot;);//&quot;http://www.baidu.com?hello%20world!&quot; encodeURIComponent()用途：对URI中的一段进行编码，多用于URI中的参数部分编码结果：替换所有的非字母字符 encodeURIComponent(&quot;http://www.baidu.com&quot;);//&quot;http%3A%2F%2Fwww.baidu.com&quot; encodeURIComponent(&quot;http://www.baidu.com?hello world!&quot;)//&quot;http%3A%2F%2Fwww.baidu.com%3Fhello%20world!&quot; &quot;http://www.baidu.com?name=&quot; + encodeURIComponent(&apos;张三&apos;);//&quot;http://www.baidu.com?name=%E5%BC%A0%E4%B8%89&quot; URI解码方法与2个URI编码方法对应的方法有decodeURI()、decodeURIComponent() decodeURI()用途：将经过encodeUIR()方法编码后的URI还原解码解果：将%20还原成空格 decodeURI(&quot;http://www.baidu.com?hello%20world!&quot;);//&quot;http://www.baidu.com?hello world!&quot; decodeURIComponent()用途：将经过encodeURIComponent的URI还原解码结果：将非字母的字符还原 decodeURIComponent(&quot;%E5%BC%A0%E4%B8%89&quot;);//&quot;张三&quot;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"apply()、call()、bind()","date":"2017-01-23T02:29:44.000Z","path":"JavaScript_apply-call-bind/","text":"扩充函数作用域简介apply()和call()是每个函数所包含的方法，用于指定函数运行的作用域（修改this对象的值）；bind()用于绑定函数运行作用域并返回函数 用法apply()apply()接收两个参数，第一个参数指定函数运行时的作用域，第二个参数指定函数的参数（需是数组或者arguments对象）example1：参数传递 function sum(num1, num2) { return num1 + num2; } function callSum1(num1, num2) { return sum.apply(this, arguments);//传入arguments对象 } function callSum2(num1, num2) { return sum.apply(this, [num1, num2]);//传入数组 } example2：修改作用域 var name = &quot;first&quot;; var obj = {name: &quot;second&quot;}; function getName() { console.log(this.name); } getName();//当前作用域window：&quot;first&quot; getName.apply(this);//指定作用域为window：&quot;first&quot; getName.apply(obj);//指定作用域为obj：&quot;second&quot; call()call(）接收多个参数，第一个参数与apply一致，其余参数为函数需要的参数（需一一列举）example：参数传递 function sum(num1, num2) { return num1 + num2; } function callSum(num1, num2) { return sum.call(this, num1, num2);//指定每一个参数 } bind()bind()方法接收一个参数，参数指定函数运行时的作用域example： var name = &quot;first&quot;; var obj = {name: &quot;second&quot;}; function getName() { console.log(this.name); } var newGetName = getName.bind(obj); getName();//&quot;first&quot; newGetName();//绑定作用域为obj：&quot;second&quot;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"AngularJs学习之指令编写","date":"2017-01-20T11:38:45.000Z","path":"AngularJs_学习笔记之指令/","text":"前言（1）在controller写业务逻辑（我们明白业务逻辑大部分是放在服务中），这里所说的业务逻辑乃是为呈现视图之前而准备的数据或者是与其他指令进行数据交互而暴露这个api（2）在link中主要操作DOM开始1.指令的定义：123456.directive(&apos;hello&apos;,function()&#123; return &#123; restrict:&apos;AECM&apos;, template:&apos;&lt;label&gt;hello world&lt;/label&gt;&apos; &#125;&#125;) 这是一个最简单的指令，在这个指令中，restrice用来规定指令的使用方式，A（attribute）代表指令以属性方式调用，例如：1&lt;div hello&gt;&lt;/div&gt;; E(element)代表指令以元素名的方式调用，例如：1&lt;hello&gt;&lt;/hello&gt;; C(class)代表指令以类名方式调用，例如：1&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;; M代表指令以注释的方式调用，例如：1&lt;!-- hello --&gt;; template后跟的为html片段，同理的作用还有templateUrl,templateUrl后跟一个html链接，其内也是一段html片段；replace后跟true或false，意思为是否替换掉调用指令处的html元素；scope属性代表指令的作用域；有三种取值：false，true，{}；默认为false，代表与父作用域共享；true代表创建一个继承于父scope的scope；{}创建一个独立的作用域，如果需要使用父作用域的属性或方法可以使用“@”，“=”，“&amp;”，“@”实现的是单向绑定，“=”实现的是双向绑定，而使用“&amp;”，代表的是调用父作用域的方法；transclude属性代表是否允许指令中插入任意内容，例如transclude为true时可以这样cdio；compile有两个参数，一个element，一个attrs；element指指令所在的元素，compile返回一个方法或者对象，也可以在这里操作dom元素link包含三个参数：scope，attrs，element；正如开篇提到的，link函数用于操作dom元素；controller同时也可以与其它指令交互，当别的指令与本指令交互时，对应的指令需要声明本指令的实例（require:’^本指令名称’)","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"AngularJs学习之ui-router","date":"2017-01-12T11:29:20.000Z","path":"AngularJs_学习笔记之ui-router/","text":"今天学了ui-router，从慕课以及自己手动敲代码，感受到了它的魅力，记得假期做过一个图书管理系统的练习，那个时候用的是iframe来实现刷新，现在看来，觉得当时还是太嫩了，进入主题吧 首先说一下为什么不使用ng-router的原因吧，我从网上学习以及找到的资料给出的解释基本上都一样，总结为：因为UI-Router有两个重要的特性：1.多样化视图 2.嵌入式视图，在实际操作中，我们总会给一个html分不同的区域，有菜单栏或者导航栏，主体内容，页脚等等，嵌入式视图就是让不同的视图同时展现或者嵌入到另一个视图中，我写了个小demo，只是为了让自己体验一下ui-router而已，写的并不规范app.js的部分代码：1234567var routerApp = angular.module(&apos;routerApp&apos;, [ &apos;ui.router&apos;, &apos;ngGrid&apos;, &apos;BookListModule&apos;, &apos;BookDetailModule&apos; ]);routerApp.run(function($rootScope, $state, $stateParams) &#123; $rootScope.$state = $state; $rootScope.$stateParams = $stateParams;&#125;); app.js的配置路由代码：12345678910111213141516171819202122232425262728293031323334353637routerApp.config(function($stateProvider, $urlRouterProvider) &#123; //运行时找不到想要的状态就会自动的进入index $urlRouterProvider.otherwise(&apos;/index&apos;); $stateProvider //state后紧跟的那个是一个状态，可以通过ui-sref指令转变状态，例如&lt;a ui-sref=&quot;second&quot;&gt;二&lt;/a&gt; .state(&apos;index&apos;,&#123; //url即地址栏的内容，当用户浏览到/index时会找到他需要的视图 url: &apos;/index&apos;, //存在多个view时使用这种写法 views:&#123; &apos;&apos;:&#123; templateUrl: &apos;tpls/loginForm.html&apos; &#125;, //@符号用在此处代表在index下存在的模块，例如我写的，在index下存在：&lt;a ui-sref=&quot;x1&quot;&gt;1&lt;/a&gt;&lt;a ui-sref=&quot;x2&quot;&gt;2&lt;/a&gt; &lt;a ui-sref=&quot;x3&quot;&gt;3&lt;/a&gt; &apos;x1@index&apos;:&#123; templateUrl: &apos;tpls/first.html&apos; &#125;, &apos;x2@index&apos;:&#123; templateUrl: &apos;tpls/second.html&apos; &#125;, &apos;x3@index&apos;:&#123; templateUrl:&apos;tpls/three.html&apos; &#125; &#125; &#125;) .state(&apos;second&apos;,&#123; url: &apos;/second&apos;, templateUrl: &apos;tpls/three.html&apos; &#125;) .state(&apos;three&apos;,&#123; url: &apos;/three&apos;, templateUrl: &apos;tpls/first.html&apos; &#125;)&#125;) 通过ui-router我们可以实现菜单与内容的分离，这样更好操控不同区域","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"数组常用方法","date":"2017-01-12T07:26:56.000Z","path":"JavaScript_数组常用方法/","text":"常用方法 检测是否是数组：Array.isArray(array); //array是数组变量，返回true/false 使用不同分隔符构建字符串：array.join(&quot;||&quot;); //将输出以||为分隔的字符串 栈方法： 12array.push(···); //向array中推如任意项var temp = array.pop(); //取出array中的最后一项并删除 队列方法：1234array.push(···); //与shift()构成队列array.shift(); //取出array中的第一项并删除array.unshift(···); //向array的前端推进任意项并返回新数组长度array.pop(); //与unshift()构成队列 重排序：123456789101112array.reverse() //反转array，第一项变成最后一项，以此类推;array.sort(function(value1, value2) &#123;//对array进行排序，可选择传入比较函数 if(value1 &gt; value2) &#123; reutrn 1; &#125; else if(value1 &lt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;) 操作方法：1234var newArray = array.concat(···); //基于array中的元素向newArray中写入任意多元素，可选择是否传参var newArray = array.slice(arg0, arg1); //无参数时复制array到newArray；一个参数时从array复制指定位置到最后一项；两个参数时从array复制指定开始位置到指定结束位置var newArray = array.splice(arg0, arg1); //从array中删除arg0开始的arg1项var newArray = array.splice(arg0, arg1, ···); //从array中arg0开始删除arg1项，并插入任意多项,newArray是空数组 位置方法：12var index = array.indexOf(arg0, arg1); //从arg0（可选参数）开始查找arg1，返回索引var index = array.lastIndex(arg0, arg1); //从array最后arg0（可选参数）位置开始查找arg1 迭代方法：共五个，都接受2个参数，第一个参数是每一项都要运行的函数，第二个参数（可选）是运行该函数的作用域对象，运行的函数接收三个参数当前项，当前项下标，数组对象，都不会修改数组中的值123456789101112131415var bool = array.every(function(item, index, arr) &#123;//对array中每项运行该函数，若都返回true，则最终结果为true return (item &gt; 2);&#125;)var bool = array.some(function(item, index, arr) &#123;//对array中每项运行该函数，若有一项返回true，则结果为true return (item &gt; 2);&#125;)var newArray = array.filter(function(item, index, arr)&#123;//对array中每项运行该函数，返回结果为true的项组成的新数组 return (item &gt; 2); &#125;)var newArray = array.map(function(item, index, arr)&#123;//对array中每项运行该函数，返回每次经过该函数的元素组成的新数组 return item * 2; &#125;)array.forEach(functrion(item, index, arr)&#123;//对array中每项运行该函数,无返回值 newArray[index] = item;//某些操作&#125;) 归并方法：共2个，这两个方法接收两个参数，第一个参数是每一项都要运行的函数，第二个参数（可选）为归并的初始值，函数接收4个参数：前一个值，当前值，数组下标，原数组；第一次迭代发生在数组第二项，故第一个参数是数组第一项，第二个参数是数组第二项123456var sum = array.reduce(function(prev, cur, index, arr) &#123;//执行求和 return prev + cur; &#125;)var sum = array.reduceRight(function(prev, cur, index, arr) &#123;//从最右方开始执行求和 return prev + cur; &#125;)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"AngularJs学习之条件化显示","date":"2017-01-11T12:08:12.000Z","path":"AngularJs_学习笔记之条件化显示/","text":"今天看到了AngularJs介绍的条件化显示,在AngularJs中拥有四套不同的指令集:ng-show/ng-hide,ng-swatch-*,ng-if,ng-include. ng-show/ng-hideng-show与ng-hide用于隐藏DOM树的一部分,它利用的是CSS规则,类似于CSS中的1style:&quot;display: none;&quot; 它并没有将元素从DOM树中移除。 ng-switchng-switch会根据条件来移除DOM节点,请注意,这里指的是“移除”,而不是“隐藏”1234&lt;div ng-switch on=&quot;showSecret&quot;&gt;&lt;div ng-switch-when=&quot;true&quot;&gt;Secret&lt;/div&gt;&lt;div ng-switch-default&gt;Won&apos;t show you my secrets!&lt;/div&gt;&lt;/div&gt; 在这个例子中,ng-switch将会监听on里面的值,只要匹配了ng-switch-when就可以将其加入进来,否则将其移除,在一个ng-switch中可以有多个ng-switch-when,ng-switch有一个问题:如果是简单用例,语法也会变得冗长,此时就需要一套新的指令集了:ng-if ng-ifng-if语法十分简单,例如:1&lt;div ng-if=&quot;showSecret&quot;&gt;&lt;/div&gt; 条件化显示的小demohtml:1234567891011&lt;table class=&quot;table table=bordered&quot; ng-controller=&quot;ListAndOneDetailCtrl&quot;&gt; &lt;tbody ng-repeat=&quot;user in users&quot; ng-click=&quot;selectUser(user)&quot; ng-switch on=&quot;isSelected(user)&quot;&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.email&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-switch-when=&quot;true&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;user.desc&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; js:12345678910111213angular.module(&apos;Myapp&apos;,[]).controller(&apos;ListAndOneDetailCtrl&apos;,function ($scope) &#123; $scope.users = [&#123;&quot;name&quot;:&quot;pawel&quot;,&quot;email&quot;:&quot;pawel@qq.com&quot;,&quot;desc&quot;:&quot;Pawel details go here&quot;&#125;, &#123;&quot;name&quot;:&quot;peter&quot;,&quot;email&quot;:&quot;perter@qq.com&quot;,&quot;desc&quot;:&quot;peter details go here&quot;&#125;]; $scope.selectUser = function (user) &#123; $scope.selectedUser = user; &#125; $scope.isSelected = function (user) &#123; return $scope.selectedUser == user; &#125;&#125;); 条件化显示可以有条件地加载和显示子模板,容易创建高度动态化的页面,所以学会以上几个指令对自己的帮助还是挺大的","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"作用域链","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_作用域/","text":"作用域链调用一个方法时，方法首先在自己的作用域中查找变量和方法，若没有找到，将查找上一级作用域链，直至找到最顶层的作用域即window，example:12345678910111213141516var person = &#123;&#125;;person.name = &quot;我&quot;; function editName() &#123; var newName = &quot;新的名字&quot;; functino changeNewName() &#123; var oldName = person.name; person.name = newName;//方法内部可以访问到person、newName、oldName &#125; changeNewName(); //此处可访问到的变量有：person、newName&#125;//此处访问到的变量有：personeditName();//该作用域链图如下。。。在02/05/jsScope.png 延长作用域执行环境有两种，全局和局部，可以使用以下两种方式： try-catch语句的catch块 with语句；with会将指定对象添加到作用域链中，example:1234567function buildUrl() &#123; var qs = &quot;?debug=true&quot;; with(location) &#123;//接收location对象 var url = href + qs;//url变量成为函数执行环境的一部分 &#125; return url;//此处能访问url变量&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"原型及原型链","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_原型及原型链/","text":"原型概念每个函数都有一个prototype属性，这个属性指向原型对象,每个原型对象都会有一个属性:constructor,这个属性指向函数,例如:12345678function Person() &#123;&#125;Person.prototype.name = &quot;me&quot;;Person.prototype.age = 21;console.log(Person.prototype); //&#123;name: &quot;me&quot;, age: 123, constructor: ƒ&#125;,指向Person的原型对象console.log(Person.prototype.constructor); //ƒ Person() &#123;&#125;,指向Person函数 每个实例都有一个[[Prototype]]属性指向其原型对象,在Firefox、Safari、Chrome中为__proto__,通过__proto__可以访问实例的原型对象 isPrototypeOf()、Object.getPrototypeOf()isPrototypeOf()用于检测实例的原型对象是否是指定的原型对象,返回值为Boolean类型,例如:console.log(Person.protorype.isPrototype(person1);Object.getPrototypeOf()用于获取对象的原型,例如:console.log(Object.getPrototypeOf(person1); //返回person1的原型 搜索属性在JavaScript中,搜索一个属性首先搜索实例中存在的属性,如果未搜索到就查找实例的原型对象,为实例添加属性时将屏蔽原型对象中的同名属性,使用delete操作符删除实例中的属性后,就能重新访问原型中的同名属性 hasOwnProperty()、in操作符、Object.getOwnPropertyDescriptor(s)hasOwnProperty(),正如方法名称:”自己的属性”,所以该方法用于检测属性是否存在于实例中,若存在于实例中则返回true,存在于原型中或属性不存在返回falsein操作符可以访问到实例中或原型中的属性,与hasOwnProperty()方法结合使用可以知道属性是实例中的属性还是原型中的属性,例如:12345678var person1 = new Person();person1.name = &quot;hello&quot;; //赋值后屏蔽了原型中的name属性console.log(&quot;name&quot; in person1); //truefor(var i in person1) &#123;//可枚举的属性 console.log(i); //name、age 访问到了所有的实例、原型中属性&#125; Object.getOwnPropertyDescriptor(s)方法用于获取实例属性的描述符,若要获取原型对象的属性描述符就需要在原型对象上调用该方法,例如:123var person1Str = Object.getOwnPropertyDescriptors(person1);var personStr = Object.getOwnPropertyDescriptors(Person.prototype); 原型链概念原型对象包含另一个原型,另一个原型又包含另一个原型,依次递推,实例和原型构成的结构就是原型链,原型链主要用于实现继承","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"作用域链","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_作用域链/","text":"作用域链调用一个方法时，方法首先在自己的作用域中查找变量和方法，若没有找到，将查找上一级作用域链，直至找到最顶层的作用域即window，example:12345678910111213141516var person = &#123;&#125;;person.name = &quot;我&quot;; function editName() &#123; var newName = &quot;新的名字&quot;; functino changeNewName() &#123; var oldName = person.name; person.name = newName;//方法内部可以访问到person、newName、oldName &#125; changeNewName(); //此处可访问到的变量有：person、newName&#125;//此处访问到的变量有：personeditName();//该作用域链图如下。。。在02/05/jsScope.png 延长作用域执行环境有两种，全局和局部，可以使用以下两种方式： try-catch语句的catch块 with语句；with会将指定对象添加到作用域链中，example:1234567function buildUrl() &#123; var qs = &quot;?debug=true&quot;; with(location) &#123;//接收location对象 var url = href + qs;//url变量成为函数执行环境的一部分 &#125; return url;//此处能访问url变量&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"闭包","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_闭包/","text":"概念闭包是指有权访问另一个函数作用域中中的变量的函数,最常见的方式就是在一个函数中创建另一个函数，例如:12345678910111213141516function getFunctions() &#123; var functions = new Array(); for(var i = 0; i &lt; 10; i++) &#123; functions[i] = function() &#123; return i; &#125; &#125; return functions;&#125;var array = getFunctions(); //每个函数都保存了getFunctions的活动对象,所以每个函数访问的变量都是同一个console.log(array[0]()); //10console.log(array[0]()); //10 this对象在闭包中,this对象的实际效果可能会与想法不一致,例如:12345678910111213var name = &quot;ddd&quot;;var object = &#123; name: &quot;object&quot;, getName: function() &#123; return function() &#123; return this.name; &#125; &#125;&#125;console.log(object.getName()()); //ddd 导致这样的结果是由于返回的一个匿名函数,而匿名函数的执行环境具有全局性,即this指向window,解决此问题的办法是在返回匿名函数前将this赋值给变量,因为此时的this在作用域中引用的是object,如下：1234567891011121314var name = &quot;ddd&quot;;var object = &#123; name: &quot;object&quot;, getName: function() &#123; var that = this; return function() &#123; return that.name; &#125; &#125;&#125;console.log(object.getName()()); //object 内存泄漏风险由于闭包会一直引用包含闭包的函数的活动对象,因此处理不当将会导致一些已使用完的垃圾不能被收回,解决方法是显式的将一些变量置为null","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"对象属性","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_对象属性/","text":"属性ECMAScript中有两种属性：数据属性和访问器属性 数据属性概念:数据属性包含属性的值的位置,在这个位置可进行读取、写入特性:1.[[Configurable]]:能否删除属性、修改属性的特性,默认值为true 2.[[Writable]]:能否修改属性的值,默认值为true 3.[[Enumberable]]:能否枚举出该属性,默认值为true 4.[[Value]]:属性的值,默认值为undefined 访问器属性概念:访问器属性不包含数据值,有一队getter()和setter()(这两个函数不是必须的),读取访问器属性会调用getter(),同理写入时会调用setter()特性:1.[[Configurable]]:能否删除、修改属性的特性 2.[[Enmuberable]]:能否枚举出该属性 3.[[Get]]:读取属性时调用 4.[[Set]]:写入属性时调用 修改属性特性Object.defineProperty()接收三个参数,第一个参数:属性所在对象,第二个参数:属性名字,第三个参数:特性,例如:1234567891011121314151617181920212223242526272829303132var person = &#123;&#125;;&lt;!-- 若第三个参数未设置,则configurable、enumberable、writable默认为false --&gt;Object.defineProperty(person, &quot;name&quot;, &#123; configurable: true, //该属性设置为false则不可再更改为true,若设置为false只能修改writable特性 writable: false, enumberable: false, value: &quot;me&quot;&#125;);var book = &#123; _year: 2017 // _XXX代表只能通过对象方法访问该属性&#125;;&lt;!-- 只指定getter()意味着不能写,同样地只指定setter()意味着不可读 --&gt;Object.defineProperty(book, &quot;year&quot;, &#123; get: function() &#123; return this._year; &#125;, set: function(newYear) &#123; this_year = newYear; &#125;&#125;);&lt;!-- 定义访问器属性的旧方法 --&gt;book.__defineGetter__(&quot;year&quot;, function() &#123; return this._year;&#125;;book.__defineSetter__(&quot;year&quot;, function(newYear) &#123; this._year = newYear;&#125; Object.defineProperties()用于同时定义多个属性,该方法接收两个参数,第一个参数是对象，第二个参数是对象的属性1234567891011121314151617var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2017 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newYear) &#123; this_year = newYear; &#125; &#125;&#125;) 获取属性特性Object.getOwnPropertyDescriptor()用于获取指定对象中指定属性的描述符(仅限与实例对象,原型属性需要在原型对象上调用),第一个参数是对象，第二个参数是指定属性的名称1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2017 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newYear) &#123; this_year = newYear; &#125; &#125;&#125;);var des = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);console.log(des); //&#123;value: 2017, writable: true, enumerable: false, configurable: false&#125; Object.getOwnPropertyDescriptors用于获取指定对象中所有属性的描述符(仅限与实例对象,原型属性需要在原型对象上调用),接收一个对象参数123456789101112131415161718192021var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2017 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newYear) &#123; this_year = newYear; &#125; &#125;&#125;);var des = Object.getOwnPropertyDescriptors(book);console.log(des); //year:&#123;get: ƒ, set: ƒ, enumerable: false, configurable: false&#125; //_year:&#123;value: 2017, writable: true, enumerable: false, configurable: false&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"AJAX","date":"2017-01-09T12:00:35.000Z","path":"JavaScript_AJAX/","text":"AJAX什么是AJAX?AJAX全拼Asynchronous JavaScript and XML,意为异步JavaScript和XML,用于解决用户向后台发起请求后不需重新加载整个页面,只要将获取的数据插入到指定位置即可,提高了应用程序的执行能力 AJAX核心AJAX核心对象是XMLHttpRequest,通过这个对象中的方法可以实现异步通信12345678910var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;http://www.xxxx.com/api&quot;, false); //xhr.open接收3个参数(请求方式, 请求URL, 是否异步)xhr.send(null);if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.responseText);&#125;else &#123; console.log(xhr.status);&#125; 在IE7之前使用ActiveXObject对象实现相同的功能:var xhr = new ActiveXObject(不同版本); //3个版本:&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;兼容IE7之前版本的AJAX写法12345678910111213141516171819202122function createXHR() &#123; if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123; return new XMLHttpRequest(); &#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123; if(typeof arguments.callee.activeXString != &apos;string&apos;) &#123; var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],i,len; for(i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error(&quot;No XHR object available.&quot;); &#125; &#125; 在XHR中属性readyState代表请求/响应的活动阶段,有4个活动阶段: 0:未初始化(还未调用open方法) 1:启动(调用了open,还未调用send方法) 2:发送(调用了send,但未响应) 3:接收(收到部分响应数据) 4:完成(响应数据接收完毕)若想取消异步请求,可以使用xhr.abort() AJAX进度事件目前的W3C草案共有6个事件,前五个已被大部分浏览器支持: loadstart: 在接收到响应数据的第一个字节时触发 progress: 在接收响应期间持续不断触发 error: 请求发生错误时触发 abort: 因为调用abort()方法后触发 load: 接收到完整的响应数据时触发 loadend: 在通信完成或者error、abort、load事件后触发 AJAX流程通过AJAX获取数据的过程中可能会有一段空白区,而在这段空白区之间JavaScript将继续执行,接收到服务器的响应后第一件事是检测状态,如果状态正确就可以取出数据更新局部页面![此处输入图片的描述][1] AJAX相关API启动一个请求:xhr.open(方法, URL, 是否异步)发送数据给服务器:xhr.send(数据)监听readystate变化,需要在open()方法前指定:xhr.onreadystatechange: function() {}中止异步请求:xhr.abort()设置请求头部,需要在open()方法后send()方法前:xhr.setRequestHeader(名称, 值)获取指定名称的响应头部:xhr.getResponseHeader(名称)获取所有响应信息:xhr.getAllResponseHeaders()设置超时时间:xhr.timeout = 毫秒请求超时后触发该函数:xhr.ontimeout = function() {}重写响应的MIME类型:xhr.overrideMimeType(类型) //xhr.overrideMimeType(&quot;text/xml&quot;) [1]: https://raw.githubusercontent.com/jacklincao/myImages/master/hexoImages/2018/03/02/Ajax1.jpg 跨域什么是CORS?CORS: Cross-Origin Resource Sharing(跨源域资源共享),用一些技术实现请求非同源域下的资源基本思想:让浏览器与服务器进行沟通,判断能否成功请求,请求时浏览器会在请求头部加上Origin,服务器收到后对此做验证,若同意请求,服务器发回的响应将包含Access-Control-Allow-Origin(这个头部返回的内容要与发送的源信息一致或”*”),若无此字段浏览器将报错默认行为:跨域请求不发送cookie、HTTP认证等,通过设置withCredentials为true,这样浏览器就会发送cookie等信息,同时服务器的响应头部需要有:Access-Control-Allow-Credentials: true,否则浏览器将报错 Preflighted Requests:CORS可通过该机制获取服务器是否允许跨域,发送Preflight请求将使用OPTIONS方法,同时带上以下头部: Origin:源信息 Access-Control-Request-Method:请求时使用的方法 Access-Control-Request-Headers:自定义头部信息若服务器同意请求,服务器将返回下列头部给浏览器 Access-Control-Allow-Origin:与请求源相同或”*” Access-Control-Allow-Methods:服务器接受的方法,以逗号分隔 Access-Control-Allow-Headers:服务器接受的头部,以逗号分隔 Access-Control-Max-Age:Preflight缓存时间(秒),在缓存期内无需再发Preflight请求跨浏览器的CORS实现1234567891011121314function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (&quot;withCredentials&quot; in xhr) &#123; xhr.open(method, url, true); &#125; //针对IE浏览器 else if (typeof XDomainRequest != &quot;undefined&quot;) &#123; xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125; 其它跨域技术JSONPJSONP全称JSON with padding(填充式JSON),JSONP由两部分组成:回调函数与数据,例如请求:http://www.xxx.com/?callback=handleResponse,当浏览器收到响应后将执行handleResponse方法使用方式:通过动态&lt;script&gt;元素使用,使用时为&lt;script&gt;元素的src指定跨域URL,请求完成后将会立即执行回调1234567function handleResponse(res) &#123; console.log(&quot;服务器发送:&quot; + res.text);&#125;var script = document.createElement(&quot;script&quot;);script.src = &quot;http://www.xxx.com/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild); 缺点:1.不安全,因为代码不确定2.不容易确定JSONP请求失败","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"typeof和instanceof","date":"2017-01-02T07:07:35.000Z","path":"JavaScript_typeof和instanceof/","text":"基本类型基本类型有以下五种： Undefined Null Boolean Number String typeof操作符用于检测变量的数据类型检测结果有以下6种： “undefined” 未定义 “boolean” 布尔类型 “string” 字符串 “number” 数字 “object” 对象或null “function” 函数example:12345678var tempString = &quot;Hello World!&quot;;var tempNumber = 123;var tempBool = true;var tempUndefined;console.log(typeof tempString); //&quot;string&quot;console.log(typeof tempNumber); //&quot;number&quot;console.log(typeof tempBool); //&quot;boolean&quot;console.log(typeof tempUndefined) //&quot;undefined&quot; instanceof操作符用于检测引用类型，判断给定变量是否是指定的引用类型，若使用其来检测基本数据类型都将返回false，因为其不是引用类型example:12345var person = &#123;&#125;;var persons = [];console.log(person instanceof Object); //trueconsole.log(persons instanceof Array); //trueconsole.log(persons intanceof Object); //true，因为所有引用类型都是Object的实例","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"垃圾回收(GC)","date":"2016-12-22T14:07:35.000Z","path":"JavaScript_垃圾回收/","text":"概念垃圾回收机制为了保证浏览器运行正常,需要对其内存进行管理,而JavaScript的垃圾回收机制原理就是:找出不在继续使用的变量,释放这部分变量所占用的内存,垃圾回收器会按照固定的时间间隔进行此操作 实现方式最常用的两种方式分别是:标记清除法和引用计数法 标记清除原理变量进入某一个环境后,将该变量标记为”进入环境”,当变量离开该环境时,再将该变量标记为”离开环境”,垃圾回收器将标记为”离开环境”的变量占用内存回收 实现方式用变量的某个特殊位来记录变量状态,或者使用一个变量列表跟踪”离开环境”的变量 例子123456function getName() &#123; var name = &quot;me&quot;; //name变量&quot;进入环境&quot; console.log(name); &#125;getName(); //运行函数后,name变量&quot;离开环境&quot; 引用计数原理记录每个值的被引用次数,当给一个变量赋某个引用类型值后,该值的引用次数为1,若又给另一个变量赋值,该值的引用次数相应的+1,若第一个变量被赋予了新值,那么旧值的引用次数相应的-1,当该值的引用次数变为0后,由垃圾回收器进行回收 例子12345678function getName() &#123; var o1 = &#123;name: &apos;me&apos;&#125;; //对象的引用次数为1 var o2 = o1; //对象的引用次数为2 var o3 = o1; //对象的引用次数为3 o2 = &#123;&#125;; //对象的引用次数为2 o3 = &#123;&#125;; //对象的引用次数为1 o1 = &#123;&#125;; //对象的引用次数为0&#125; 循环引用使用引用技术容易引起一个问题:循环引用,在一个变量中A引用了另一个变量B,同时B引用了A1234567function cyclic() &#123; var objectA = &#123;&#125;; //对象A的引用次数为1 var objectB = &#123;&#125;; //对象B的引用次数为1 objectA.toB = objectB; //对象B的引用次数为2 objectB.toA = objectA; //对象A的引用次数为2&#125; IE中有一部分对象不是JavaScript原生对象,它的BOM、DOM对象是使用C++以（Component Object Model）的形式实现,而COM对象的垃圾回收机制是采用引用计数方式,为了解决IE中的两种垃圾回收算法并存所导致的问题,IE9将BOM、DOM转变为真正的JavaScript对象 触发时机垃圾回收器是周期性运行的,而这个触发机制根据不同的浏览器有不同的实现,而且在垃圾回收期间会阻塞JavaScript运行","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"博客开张啦","date":"2016-12-20T07:22:09.000Z","path":"博客开张啦/","text":"欢迎来到我的博客,从今天起我将开始更新,希望在这里能找到你想要的,同时分享我的各种Idea 个人简介我是一个程序猿,还是一个刚进入这个专业没多久的菜鸟,但是我喜欢技术,喜欢看到代码在我手下产生各种美妙的画面,我还在学习,我也会一直学习,这个博客我会分享出一些我的见解以及一些解决困难的方法,未来还长,请多多指教!","tags":[]},{"title":"林之博客","date":"2016-12-19T12:47:45.000Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]