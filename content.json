[{"title":"Windows下MySQL数据备份与还原","date":"2018-01-21T09:33:14.504Z","path":"MySQL备份还原/","text":"MySQL备份在MySQL中，如果视图比较多，同时视图之间存在嵌套、调用关系，为了在还原时不会报错，最好使用cmd命令备份，我使用Navicat备份过，但是由于视图太多还原失败了，运行下面的MySQL备份命令： cd C:\\Program Files\\MySQL\\MySQL x.x\\bin //进入mysql的bin目录 mysqldump -u 用户名 -p 数据库名 &gt;导出的文件名 //会要求输入密码，而产生的文件将在bin目录下 MySQL还原将刚才备份得到的文件放到另一台机器的MySQL的bin目录下，运行下面的MySQL还原命令： mysql -u 用户名 -p //之后将输入密码 mysql&gt;use 目标数据库 //选择需要还原的数据库 mysql&gt;source 导入的文件名 //bin目录下的文件名","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/jacklincao/tags/MySQL/"}]},{"title":"angular2子路由跳转","date":"2018-01-20T11:43:12.988Z","path":"angular2常见bug二/","text":"配置了路由表，并定义了子路由，但是每次跳转到子路由总是跳到404路由在angular的官方文档找到了原因：导入模块的时候需要注意顺序，我在根模块导入模块时先把主路由模块导入了，导致路由会率先匹配到通配符路由，所以跳转到404，在定义子路由时，要将子路由所在模块提前于通配符路由所在的模块！1234567891011121314151617181920212223242526272829303132//根模块路由定义在AppRoutingModule，子路由定义在FrontModule中imports: [ BrowserModule, FormsModule, HttpModule, JsonpModule, FrontModule， AppRoutingModule/*导入路由模块,顺序很重要*/ ], ......//AppRoutingModule中的路由表如下appRoutes: Routes = [ &#123;path: &apos;&apos;, redirectTo: &apos;/login&apos;, pathMatch: &apos;full&apos;&#125;, &#123;path: &apos;login&apos;, component: LoginComponent&#125;, &#123;path: &apos;**&apos;, component: PageNotFoundComponent&#125;];//FrontModule中定义的路由表如下frontRoutes: Routes = [ &#123; path: &apos;begin&apos;, component: FrontComponent, children: [ /*子路由*/ &#123;path: &apos;&apos;, component: DebateInfoComponent&#125;, &#123;path: &apos;end&apos;, component: EndComponent&#125;, ] &#125; ]; //如果AppRoutingModule先于FrontModule导入就会导致所有子路由匹配到&apos;**&apos;","tags":[{"name":"angular2常见bug","slug":"angular2常见bug","permalink":"https://github.com/jacklincao/tags/angular2常见bug/"}]},{"title":"angular2生成组件出错","date":"2018-01-20T11:42:24.457Z","path":"angular2常见bug一/","text":"使用angular CLI工具生成组件出错12Error:More than one module matches. Use skip-important option to skip importing the component into the closest module.More than one module matches. Use skip-important option to skip importing the component into the closest module. 查看了angluar CLI的官方文档，没找到原因，在stackouverflow上找到了，原因是在我的应用中有多个模块，不指明是哪一个模块的组件的话，它不知道这个组件属于谁，所以解决方法就是1ng g c \\shared\\test --module app //shared指在shared文件夹下生成test组件，它是app模块的组件 亲测成功。","tags":[{"name":"angular2常见bug","slug":"angular2常见bug","permalink":"https://github.com/jacklincao/tags/angular2常见bug/"}]},{"title":"angularJs学习之条件化显示","date":"2018-01-20T11:41:25.255Z","path":"AngularJs学习笔记之条件化显示/","text":"今天看到了angularJS介绍的条件化显示,在angularJs中拥有四套不同的指令集:ng-show/ng-hide,ng-swatch-*,ng-if,ng-include. ng-show/ng-hideng-show与ng-hide用于隐藏DOM树的一部分,它利用的是CSS规则,类似于CSS中的1style:&quot;display: none;&quot; 它并没有将元素从DOM树中移除。 ng-switchng-switch会根据条件来移除DOM节点,请注意,这里指的是“移除”,而不是“隐藏”1234&lt;div ng-switch on=&quot;showSecret&quot;&gt;&lt;div ng-switch-when=&quot;true&quot;&gt;Secret&lt;/div&gt;&lt;div ng-switch-default&gt;Won&apos;t show you my secrets!&lt;/div&gt;&lt;/div&gt; 在这个例子中,ng-switch将会监听on里面的值,只要匹配了ng-switch-when就可以将其加入进来,否则将其移除,在一个ng-switch中可以有多个ng-switch-when,ng-switch有一个问题:如果是简单用例,语法也会变得冗长,此时就需要一套新的指令集了:ng-if ng-ifng-if语法十分简单,例如:1&lt;div ng-if=&quot;showSecret&quot;&gt;&lt;/div&gt; 条件化显示的小demohtml:1234567891011&lt;table class=&quot;table table=bordered&quot; ng-controller=&quot;ListAndOneDetailCtrl&quot;&gt; &lt;tbody ng-repeat=&quot;user in users&quot; ng-click=&quot;selectUser(user)&quot; ng-switch on=&quot;isSelected(user)&quot;&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123;user.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user.email&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-switch-when=&quot;true&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;user.desc&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; js:12345678910111213angular.module(&apos;Myapp&apos;,[]).controller(&apos;ListAndOneDetailCtrl&apos;,function ($scope) &#123; $scope.users = [&#123;&quot;name&quot;:&quot;pawel&quot;,&quot;email&quot;:&quot;pawel@qq.com&quot;,&quot;desc&quot;:&quot;Pawel details go here&quot;&#125;, &#123;&quot;name&quot;:&quot;peter&quot;,&quot;email&quot;:&quot;perter@qq.com&quot;,&quot;desc&quot;:&quot;peter details go here&quot;&#125;]; $scope.selectUser = function (user) &#123; $scope.selectedUser = user; &#125; $scope.isSelected = function (user) &#123; return $scope.selectedUser == user; &#125;&#125;); 条件化显示可以有条件地加载和显示子模板,容易创建高度动态化的页面,所以学会以上几个指令对自己的帮助还是挺大的","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"angularJs学习之ui-router","date":"2018-01-20T11:40:38.706Z","path":"AngularJs学习笔记之ri-router/","text":"今天学了ui-router，从慕课以及自己手动敲代码，感受到了它的魅力，记得假期做过一个图书管理系统的练习，那个时候用的是iframe来实现刷新，现在看来，觉得当时还是太嫩了，进入主题吧 首先说一下为什么不使用ng-router的原因吧，我从网上学习以及找到的资料给出的解释基本上都一样，总结为：因为UI-Router有两个重要的特性：1.多样化视图 2.嵌入式视图，在实际操作中，我们总会给一个html分不同的区域，有菜单栏或者导航栏，主体内容，页脚等等，嵌入式视图就是让不同的视图同时展现或者嵌入到另一个视图中，我写了个小demo，只是为了让自己体验一下ui-router而已，写的并不规范app.js的部分代码：1234567var routerApp = angular.module(&apos;routerApp&apos;, [ &apos;ui.router&apos;, &apos;ngGrid&apos;, &apos;BookListModule&apos;, &apos;BookDetailModule&apos; ]);routerApp.run(function($rootScope, $state, $stateParams) &#123; $rootScope.$state = $state; $rootScope.$stateParams = $stateParams;&#125;); app.js的配置路由代码：12345678910111213141516171819202122232425262728293031323334353637routerApp.config(function($stateProvider, $urlRouterProvider) &#123; //运行时找不到想要的状态就会自动的进入index $urlRouterProvider.otherwise(&apos;/index&apos;); $stateProvider //state后紧跟的那个是一个状态，可以通过ui-sref指令转变状态，例如&lt;a ui-sref=&quot;second&quot;&gt;二&lt;/a&gt; .state(&apos;index&apos;,&#123; //url即地址栏的内容，当用户浏览到/index时会找到他需要的视图 url: &apos;/index&apos;, //存在多个view时使用这种写法 views:&#123; &apos;&apos;:&#123; templateUrl: &apos;tpls/loginForm.html&apos; &#125;, //@符号用在此处代表在index下存在的模块，例如我写的，在index下存在：&lt;a ui-sref=&quot;x1&quot;&gt;1&lt;/a&gt;&lt;a ui-sref=&quot;x2&quot;&gt;2&lt;/a&gt; &lt;a ui-sref=&quot;x3&quot;&gt;3&lt;/a&gt; &apos;x1@index&apos;:&#123; templateUrl: &apos;tpls/first.html&apos; &#125;, &apos;x2@index&apos;:&#123; templateUrl: &apos;tpls/second.html&apos; &#125;, &apos;x3@index&apos;:&#123; templateUrl:&apos;tpls/three.html&apos; &#125; &#125; &#125;) .state(&apos;second&apos;,&#123; url: &apos;/second&apos;, templateUrl: &apos;tpls/three.html&apos; &#125;) .state(&apos;three&apos;,&#123; url: &apos;/three&apos;, templateUrl: &apos;tpls/first.html&apos; &#125;)&#125;) 通过ui-router我们可以实现菜单与内容的分离，这样更好操控不同区域","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"angularJs学习之指令编写","date":"2018-01-20T11:38:41.439Z","path":"AngularJs学习笔记之指令/","text":"前言（1）在controller写业务逻辑（我们明白业务逻辑大部分是放在服务中），这里所说的业务逻辑乃是为呈现视图之前而准备的数据或者是与其他指令进行数据交互而暴露这个api（2）在link中主要操作DOM开始1.指令的定义：123456.directive(&apos;hello&apos;,function()&#123; return &#123; restrict:&apos;AECM&apos;, template:&apos;&lt;label&gt;hello world&lt;/label&gt;&apos; &#125;&#125;) 这是一个最简单的指令，在这个指令中，restrice用来规定指令的使用方式，A（attribute）代表指令以属性方式调用，例如：1&lt;div hello&gt;&lt;/div&gt;; E(element)代表指令以元素名的方式调用，例如：1&lt;hello&gt;&lt;/hello&gt;; C(class)代表指令以类名方式调用，例如：1&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;; M代表指令以注释的方式调用，例如：1&lt;!-- hello --&gt;; template后跟的为html片段，同理的作用还有templateUrl,templateUrl后跟一个html链接，其内也是一段html片段；replace后跟true或false，意思为是否替换掉调用指令处的html元素；scope属性代表指令的作用域；有三种取值：false，true，{}；默认为false，代表与父作用域共享；true代表创建一个继承于父scope的scope；{}创建一个独立的作用域，如果需要使用父作用域的属性或方法可以使用“@”，“=”，“&amp;”，“@”实现的是单向绑定，“=”实现的是双向绑定，而使用“&amp;”，代表的是调用父作用域的方法；transclude属性代表是否允许指令中插入任意内容，例如transclude为true时可以这样cdio；compile有两个参数，一个element，一个attrs；element指指令所在的元素，compile返回一个方法或者对象，也可以在这里操作dom元素link包含三个参数：scope，attrs，element；正如开篇提到的，link函数用于操作dom元素；controller同时也可以与其它指令交互，当别的指令与本指令交互时，对应的指令需要声明本指令的实例（require:’^本指令名称’)","tags":[{"name":"AngularJs学习笔记","slug":"AngularJs学习笔记","permalink":"https://github.com/jacklincao/tags/AngularJs学习笔记/"}]},{"title":"杂谈javascript之二","date":"2018-01-20T11:36:43.223Z","path":"JavaScript合集-二/","text":"javascript中的函数今天看到了JavaScript中的函数篇，很熟悉的名称：函数，重读一遍后又收获了一些新知识12345678parseInt(&apos;123&apos;);parseInt(&apos;abc123&apos;);parseInt(&apos;1abc23&apos;);parseInt(&apos;123abc&apos;);parseInt(&apos;FF&apos;,10);parseInt(&apos;FF&apos;,16);parseInt(&apos;0377&apos;);parseInt(&apos;0x377&apos;); 以上函数分别输出123，NaN，1,123,NaN,255,255,887；是不是发现自己猜想的结果与实际输出悬殊比较大？如果自己的结果错了，那请记住这些，避免下次再犯这种错误。 在地址栏传参数时，可能会有中文乱码的情况，这时请参考使用12encodeURIComponent(url);decodeURIComponent(url); 回调函数的应用：先来看一段代码12345678910111213141516171819function multi(a,b,c) &#123; var i,ar = []; for(i = 0; i &lt; 3; i++) &#123; ar[i] = arguments[i] * 2; &#125; return ar;&#125;function addOne(a) &#123; return a + 1;&#125;var myarr = [];myarr = multi(10, 20, 30);for (var i = 0; i &lt; 3 ; i++) &#123; myarr[i] = addOne(myarr[i]);&#125;alert(myarr); 你会发现这段代码的数据量比较大，同时循环操作复杂，所以我们换一下，改用回调函数，请看下面的代码： 123456789function multi(a,b,c,callback) &#123; var i,ar = []; for(i = 0; i &lt; 3; i++) &#123; ar[i] = callback(arguments[i] * 2); &#125; return ar;&#125;var myarr = [];myarr = multi(1, 2, 3, addOne); 再次优化一下:123multi(a,b,c,function (a) &#123; return a + 1;&#125;) 即时函数，就是一打开html它就会自动的调用，这种函数有以下几个 1234567891011window.onload = function()&#123;&#125;$(function()&#123;&#125;)(function()&#123;&#125;)() 关于变量提升的问题：1234567var a = 123;function f() &#123; alert(a); var a = 1; alert(a);&#125;f(); 以上的代码将会依次弹出”undefined”和”1”;在这段代码里展示了两个概念:函数域始终优先于全局域;JavaScript进入新函数时，该函数内部被声明的所有变量都会被移动(提升)到函数最开始的地方，所以上面代码等效于下面的：1234567var a = 123;function f() &#123; var a; alert(a); a = 1; alert(a);&#125; 重写自己的函数：这项技术对于某些浏览器的相关操作会有特别的作用，在不同浏览器中，实现相同任务的方法可能不同，所以我们可以让函数根据当前所在浏览器重定义自己，这就是“浏览器兼容性探测”123456789101112var a = (function () &#123; function sonmeSetup() &#123; var setup = &apos;done&apos;; &#125; function actualWork() &#123; alert(&apos;Worky-worky&apos;); &#125; someSetup(); return actualWork;&#125;()); 接下来到了比较有趣的了：闭包；先来看一段代码，在outer()中定义了inner(),在inner()中可以访问的变量来自自身作用域或父级作用域，这形成了一条作用域链123456789var global = 1;function outer() &#123; var outer_local = 2; function inner() &#123; var inner_local = 3; return innner_local+outer_local+global; &#125; return inner();&#125; 闭包#11234567891011121314var a = &quot;glo&quot;;var F = function() &#123; var b = &quot;local&quot;; var N = function() &#123; var c = &quot;inner local&quot;; return b; &#125;; return N;&#125;;alert(b);var inner = F();inner(); 闭包#2:声明一个全局函数的占位符，调用F()看结果是什么1234567891011var innner;var F = function() &#123; var b = &quot;local&quot;; var N = function() &#123; return b; &#125;; inner = N;&#125;F();inner(); 闭包#3：每个函数本身就是一个闭包，因为每个函数至少都有访问全局作用域的权限，12345678910function F(param) &#123; var N = function() &#123; return param; &#125;; param++; return N;&#125;这样调用：var inner = F(123); inner(); 闭包#4之循环中的闭包:我们看一个三次的循环操作，在每次迭代中都会创建一个返回当前循环序号的新函数，该新函数将被添加到一个数组中，并返回;1234567891011121314function F() &#123; var arr = [],i; for(i = 0; i &lt; 3; i++) &#123; arr[i] = function() &#123; return i; &#125;; &#125; return arr;&#125;运行：var arr = F();arr[0]();arr[1]();arr[2](); 如果想要输出0,1,2的话，那就需要换一种闭包形式：1234567891011121314151617181920212223242526function F() &#123; var arr = [],i; for(i = 0; i &lt; 3; i++) &#123; arr[i] = (function(x) &#123; return function() &#123; return x; &#125; &#125;(i)); &#125; return arr;&#125;或function F() &#123; function binder(x) &#123; return function() &#123; return x; &#125;;&#125;var arr = [],i;for(i = 0; i &lt; 3; i++) &#123; arr[i] = binder(i);&#125;return arr;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"JavaScript学习<一>","date":"2018-01-20T11:35:32.293Z","path":"JavaScript合集-一/","text":"javascript中的基本数据类型及部分操作重新看了javascript，发现了一些平时不被关注的小问题，现在分享出来，大家一起看看12var n = 0377;alert(n); 看到这段代码，你认为它将输出什么？0377吗？如果是0377，那么恭喜你，回答错误！你可以在浏览器上的控制台敲一下试试，你会发现它的输出并不是0377，而是255，为什么是255呢？因为当数字以0开头时代表这个数是八进制数，如果以0x开头，则这个数代表十六进制，例如：0xff；123var a = 1e1;var b = 1e+1;var c = 2e+3; 请自己运行试试会输出怎样的结果，好吧，我也不卖关子了，这几个表达式代表的是javascript中的指数表达式，意思是在某个数后加几个0，比如2e+3指的就是在2后面加3个0，或者也可以理解为将数字2的小数点向右移动3位在javascript中有一个叫做Infinity的特殊值，它代表的是超过了JavaScript处理范围的值，当输入1e308时，正常，但是只要你输入了1e309就出界了，另外任何数除以0结果仍是Infinity，可以在console中运行一下语句123456Infinity;typeof Infinity;1e308;1e309;var a = 6/0;alert(a); Infinity与其它任何操作数执行算术运算的结果都等于Infinity；在javascript中，数字字符串转换为数字有一种偷懒的方法：将该字符串与1相乘即可,当然，更好的方法是调用parseInt()函数；例如：1234var n = &apos;1&apos;;typeof n;n = n*1;typeof n; 接下来看看JavaScript的数组：12var a = [1,2,3];a[6] = &apos;new&apos;; 以上代码将会在下标2到5之间产生3个undefined如果执行以下代码：12var a = [1,2,3];delete a[1]; 删除特定的元素数组长度不会受到影响，只是被删除的位置被留空了1234567var a = 1;var result = &apos;&apos;;if (a==1) &#123; result = &quot;a is one&quot;;&#125; else &#123; result = &quot;a is not one&quot;;&#125; 看完以上代码再来看看下面的代码：12var a = 1;var result = (a == 1) ? &quot;a is one&quot; : &quot;a is not one&quot;; 是不是感觉第二种方式好简洁，所以在写一些简单的条件表达式可以使用其它形式代替if表达式，但是只限于一些非常简单的条件逻辑，如果在if表达式中使用了太多的else if 字句，请考虑使用switch语句来替代if12345var a = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];var result = &apos;\\n&apos;;for (var i in a) &#123; result += &apos;index: &apos; + i + &apos;, value: &apos; + a[i] + &apos;\\n&apos;;&#125; JavaScript回忆一JavaScript中有五大基本数据类型：number;string;boolean;undefined;null;任何不属于基本数据类型的东西都属于对象；数组是一种数据存储形式，数组能存储任何类型的数组，包括另一个数组","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/jacklincao/tags/JavaScript/"}]},{"title":"博客开张啦","date":"2018-01-20T11:29:42.261Z","path":"博客开张啦/","text":"欢迎来到我的博客,从今天起我将开始更新,希望在这里能找到你想要的,同时分享我的各种Idea 个人简介我是一个程序猿,还是一个刚进入这个专业没多久的菜鸟,但是我喜欢技术,喜欢看到代码在我手下产生各种美妙的画面,我还在学习,我也会一直学习,这个博客我会分享出一些我的见解以及一些解决困难的方法,未来还长,请多多指教!","tags":[]},{"title":"git使用日记","date":"2018-01-20T11:27:03.797Z","path":"git使用日记/","text":"git常用命令为了方便自己以后使用git命令，避免网上查阅，所以用这个记录了一些常用的命令： git status 查看仓库当前状态 git add xx 提交文件xx到暂存区 git diff xx 查看xx文件做了什么修改 git commit -m “描述” 提交修改时带上描述，将暂存区提交到当前分支 git log 查看commit（提交）历史记录 可加上 –pretty=oneline 过滤其它信息，加上--graph git reset --hard HEAD^ 回退到上一版本，如果有多个版本，可以使用HEAD^^（回退上上个版本），HEAD~100（回退到100个版本） git reset --hard xxxxxxx 指定回到某个版本号 git reflog 记录每一次命令操作 git checkout -- xx 撤销对xx文件的全部修改操作；一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git rm xx 从版本库删除xx文件 git clone git@www.xx.com:/home/xx.git 克隆到本地 git branch zz 创建zz分支 git checkout zz 切换到zz分支 git checkout -b zz 创建并切换到zz分支，是上面两条的简写，如果要将远程的zz分支同步下来,则需要:git checkout -b zz origin/zz git branch 列出所有分支，当前分支前会有* git merge zz 将zz分支合并到当前分支 git branch -d zz 删除zz分支 git merge --no-ff -m “信息” zz 将zz分支合并到当前分支，并保留zz分支信息 git stash 将工作现场存储起来，以后可以恢复 git stash list 列举保存的工作现场 git stash apply stash@{0} -&gt; git stash drop stash@{0} 先将工作现场0恢复，然后删除工作现场0 git stash pop 恢复的同时删除现场 git remote 查看远程仓库信息，加上-v显示更详细信息 git push origin zz 向远程分支推送zz分支 git pull 将最新的提交从远程抓下来，在本地进行合并后再提交 git branch –-set-upstream zz origin/zz 设置zz分支对应远程仓库的zz分支 git tag v1.0 在当前分支上创建v1.0标签，加上 5134234参数代表在这个commit上打标签 git tag 查看所有标签 git show v1.0 查看v1.0标签信息 git tag -a v1.0 -m “这是v1.0版本” 21312在当前分支的21312commit上添加标签名为v1.0，内容为”这是v1.0版本”的标签，-a指定标签明，-m指定说明文字 图1 关于分支管理的策略:图片来自廖雪峰博客 图2 关于多人协作时的工作模式：图片来自廖雪峰博客","tags":[{"name":"git使用","slug":"git使用","permalink":"https://github.com/jacklincao/tags/git使用/"}]},{"title":"林之博客","date":"2016-12-19T06:23:05.894Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]